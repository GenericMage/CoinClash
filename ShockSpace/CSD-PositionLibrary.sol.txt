// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.1;

// Version 0.0.4:
// - Updated closeLongPosition payout:
//   payout = ((taxedMargin + totalMargin + leverageAmount) / currentPrice) - initialLoan (tokenB)
// - Updated closeShortPosition payout:
//   payout = (minPrice - currentPrice) * initialMargin * leverage / currentPrice + (taxedMargin + totalMargin) * currentPrice (tokenA)
// - No changes to enterLong, enterShort (liquidation prices and initial loans correct).
// - No changes to forceExecution, addExcessMargin, cancelPosition, updateSL, updateTP, batch operations.

import "imports/SafeERC20.sol";
import "imports/Strings.sol";
import "imports/IERC20Metadata.sol";

contract CSDPositionLibrary {
    using SafeERC20 for IERC20;

    // Constants
    uint256 private constant DECIMAL_PRECISION = 1e18;

    // Structs
    struct PositionDetails {
        address makerAddress;
        uint256 minPrice;
        uint256 maxPrice;
        uint256 initialMargin;
        uint256 taxedMargin;
        uint256 excessMargin;
        uint8 leverage;
        uint256 leverageAmount;
        uint256 initialLoan;
        uint256 liquidationPrice;
        uint256 stopLossPrice;
        uint256 takeProfitPrice;
        uint8 positionType;
        bool status1;
        uint8 status2;
        uint256 closePrice;
        uint256 priceAtEntry;
        uint256 positionId;
        address listingAddress;
    }

    struct PayoutUpdate {
        address recipient;
        uint256 required;
        uint8 payoutType;
    }

    // Interfaces
    interface ISSListing {
        function prices(address listingAddress) external view returns (uint256);
        function volumeBalances(address listingAddress) external view returns (uint256 xBalance, uint256 yBalance);
        function liquidityAddresses(address listingAddress) external view returns (address);
        function tokenA() external view returns (address);
        function tokenB() external view returns (address);
        function ssUpdate(address listingAddress, PayoutUpdate[] calldata updates) external;
    }

    interface ISSLiquidity {
        function addFees(bool isX, uint256 amount) external;
    }

    interface ICSDUtilityLibrary {
        function normalizeAmount(address token, uint256 amount) external view returns (uint256);
        function parseEntryPrice(string memory entryPrice, address listingAddress) external view returns (uint256 minPrice, uint256 maxPrice);
        function parseUint(string memory str) external pure returns (uint256);
    }

    interface ISSCrossDriver {
        function positionDetails(uint256 positionId) external view returns (PositionDetails memory);
        function pendingPositions(address listingAddress, uint8 positionType) external view returns (uint256[] memory);
        function positionsByType(uint8 positionType) external view returns (uint256[] memory);
        function makerTokenMargin(address maker, address token) external view returns (uint256);
    }

    // Enter long position
    function enterLong(
        address listingAddress,
        string memory entryPrice,
        uint256 initialMargin,
        uint256 excessMargin,
        uint8 leverage,
        uint256 stopLossPrice,
        uint256 takeProfitPrice,
        address token0,
        uint256 normalizedInitialMargin,
        uint256 normalizedExcessMargin,
        uint256 totalMargin,
        address driver
    ) external returns (uint256 positionId) {
        require(initialMargin > 0, "Invalid margin");
        require(leverage >= 2 && leverage <= 100, "Invalid leverage");

        // Parse entry price
        (uint256 minPrice, uint256 maxPrice) = ICSDUtilityLibrary(driver).parseEntryPrice(entryPrice, listingAddress);
        require(minPrice > 0, "Invalid entry price");

        // Calculate taxed margin and fee
        uint256 fee = (leverage - 1) * initialMargin / 100;
        uint256 taxedMargin = initialMargin - fee;

        // Calculate leverage amount
        uint256 leverageAmount = initialMargin * leverage;

        // Calculate liquidation price
        uint256 marginRatio = (totalMargin + taxedMargin) / leverageAmount;
        uint256 liquidationPrice = marginRatio < minPrice ? minPrice - marginRatio : 0;

        // Calculate initial loan
        uint256 initialLoan = leverageAmount / (minPrice / DECIMAL_PRECISION);

        // Transfer taxedMargin + excessMargin to listingAddress
        address listingToken = token0;
        if (listingToken == address(0)) {
            payable(listingAddress).transfer(taxedMargin + excessMargin);
        } else {
            IERC20(listingToken).safeTransfer(listingAddress, taxedMargin + excessMargin);
        }

        // Send fee to liquidity
        address liquidityAddr = ISSListing(listingAddress).liquidityAddresses(listingAddress);
        if (fee > 0) {
            if (listingToken == address(0)) {
                payable(liquidityAddr).transfer(fee);
            } else {
                IERC20(listingToken).safeTransfer(liquidityAddr, fee);
            }
            ISSLiquidity(liquidityAddr).addFees(true, fee);
        }

        // Create position
        positionId = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, positionId)));
        PositionDetails memory pos = PositionDetails({
            makerAddress: msg.sender,
            minPrice: minPrice,
            maxPrice: maxPrice,
            initialMargin: initialMargin,
            taxedMargin: taxedMargin,
            excessMargin: excessMargin,
            leverage: leverage,
            leverageAmount: leverageAmount,
            initialLoan: initialLoan,
            liquidationPrice: liquidationPrice,
            stopLossPrice: stopLossPrice,
            takeProfitPrice: takeProfitPrice,
            positionType: 0,
            status1: false,
            status2: 0,
            closePrice: 0,
            priceAtEntry: minPrice,
            positionId: positionId,
            listingAddress: listingAddress
        });

        // Store via driver
        (bool success, ) = driver.call(
            abi.encodeWithSignature(
                "setPositionDetails(uint256,(address,uint256,uint256,uint256,uint256,uint256,uint8,uint256,uint256,uint256,uint256,uint256,uint8,bool,uint8,uint256,uint256,uint256,address))",
                positionId,
                pos
            )
        );
        require(success, "Storage failed");

        // Update indexes
        (success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePositionIndexes(address,uint8,uint256)",
                msg.sender,
                0,
                positionId
            )
        );
        require(success, "Index update failed");

        (success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePendingPositions(address,uint8,uint256)",
                listingAddress,
                0,
                positionId
            )
        );
        require(success, "Pending index update failed");
    }

    // Enter short position
    function enterShort(
        address listingAddress,
        string memory entryPrice,
        uint256 initialMargin,
        uint256 excessMargin,
        uint8 leverage,
        uint256 stopLossPrice,
        uint256 takeProfitPrice,
        address token1,
        uint256 normalizedInitialMargin,
        uint256 normalizedExcessMargin,
        uint256 totalMargin,
        address driver
    ) external returns (uint256 positionId) {
        require(initialMargin > 0, "Invalid margin");
        require(leverage >= 2 && leverage <= 100, "Invalid leverage");

        // Parse entry price
        (uint256 minPrice, uint256 maxPrice) = ICSDUtilityLibrary(driver).parseEntryPrice(entryPrice, listingAddress);

        // Calculate taxed margin and fee
        uint256 fee = (leverage - 1) * initialMargin / 100;
        uint256 taxedMargin = initialMargin - fee;

        // Calculate leverage amount
        uint256 leverageAmount = initialMargin * leverage;

        // Calculate liquidation price
        uint256 marginRatio = (totalMargin + taxedMargin) / leverageAmount;
        uint256 liquidationPrice = minPrice + marginRatio;

        // Calculate initial loan
        uint256 initialLoan = leverageAmount * minPrice;

        // Transfer taxedMargin + excessMargin to listingAddress
        address listingToken = token1;
        if (listingToken == address(0)) {
            payable(listingAddress).transfer(taxedMargin + excessMargin);
        } else {
            IERC20(listingToken).safeTransfer(listingAddress, taxedMargin + excessMargin);
        }

        // Send fee to liquidity
        address liquidityAddr = ISSListing(listingAddress).liquidityAddresses(listingAddress);
        if (fee > 0) {
            if (listingToken == address(0)) {
                payable(liquidityAddr).transfer(fee);
            } else {
                IERC20(listingToken).safeTransfer(liquidityAddr, fee);
            }
            ISSLiquidity(liquidityAddr).addFees(false, fee);
        }

        // Create position
        positionId = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, positionId)));
        PositionDetails memory pos = PositionDetails({
            makerAddress: msg.sender,
            minPrice: minPrice,
            maxPrice: maxPrice,
            initialMargin: initialMargin,
            taxedMargin: taxedMargin,
            excessMargin: excessMargin,
            leverage: leverage,
            leverageAmount: leverageAmount,
            initialLoan: initialLoan,
            liquidationPrice: liquidationPrice,
            stopLossPrice: stopLossPrice,
            takeProfitPrice: takeProfitPrice,
            positionType: 1,
            status1: false,
            status2: 0,
            closePrice: 0,
            priceAtEntry: minPrice,
            positionId: positionId,
            listingAddress: listingAddress
        });

        // Store via driver
        (bool success, ) = driver.call(
            abi.encodeWithSignature(
                "setPositionDetails(uint256,(address,uint256,uint256,uint256,uint256,uint256,uint8,uint256,uint256,uint256,uint256,uint256,uint8,bool,uint8,uint256,uint256,uint256,address))",
                positionId,
                pos
            )
        );
        require(success, "Storage failed");

        // Update indexes
        (success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePositionIndexes(address,uint8,uint256)",
                msg.sender,
                1,
                positionId
            )
        );
        require(success, "Index update failed");

        (success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePendingPositions(address,uint8,uint256)",
                listingAddress,
                1,
                positionId
            )
        );
        require(success, "Pending index update failed");
    }

    // Close long position
    function closeLongPosition(
        uint256 positionId,
        address listingAddress,
        address makerAddress,
        uint256 taxedMargin,
        uint256 excessMargin,
        uint256 leverageAmount,
        uint256 initialLoan,
        uint256 totalMargin,
        address driver
    ) external returns (uint256 payout) {
        // Validate margin
        address token = ISSListing(listingAddress).tokenA();
        (bool success, bytes memory data) = driver.call(
            abi.encodeWithSignature(
                "makerTokenMargin(address,address)",
                makerAddress,
                token
            )
        );
        require(success, "Margin query failed");
        uint256 availableMargin = abi.decode(data, (uint256));
        require(availableMargin >= taxedMargin + totalMargin, "Insufficient margin");

        // Calculate payout
        uint256 currentPrice = ISSListing(listingAddress).prices(listingAddress);
        payout = currentPrice > 0 ? ((taxedMargin + totalMargin + leverageAmount) / currentPrice) - initialLoan : 0;

        // Update status
        (success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePositionStatus(uint256,uint8)", positionId, 1
            )
        );
        require(success, "Status update failed");

        // Issue payout order
        if (payout > 0) {
            PayoutUpdate[] memory updates = new PayoutUpdate[](1);
            updates[0] = PayoutUpdate({
                recipient: makerAddress,
                required: payout,
                payoutType: 0
            });
            ISSListing(listingAddress).ssUpdate(listingAddress, updates);
        }
    }

    // Close short position
    function closeShortPosition(
        uint256 positionId,
        address listingAddress,
        address makerAddress,
        uint256 minPrice,
        uint256 initialMargin,
        uint8 leverage,
        uint256 taxedMargin,
        uint256 excessMargin,
        uint256 totalMargin,
        address driver
    ) external returns (uint256 payout) {
        // Validate margin
        address token = ISSListing(listingAddress).tokenB();
        (bool success, bytes memory data) = driver.call(
            abi.encodeWithSignature(
                "makerTokenMargin(address,address)",
                makerAddress,
                token
            )
        );
        require(success, "Margin query failed");
        uint256 availableMargin = abi.decode(data, (uint256));
        require(availableMargin >= taxedMargin + totalMargin, "Insufficient margin");

        // Calculate payout
        uint256 currentPrice = ISSListing(listingAddress).prices(listingAddress);
        uint256 priceDiff = minPrice > currentPrice ? minPrice - currentPrice : 0;
        uint256 profit = currentPrice > 0 ? (priceDiff * initialMargin * leverage) / currentPrice : 0;
        uint256 marginReturn = currentPrice > 0 ? (taxedMargin + totalMargin) * currentPrice : 0;
        payout = profit + marginReturn;

        // Update status
        (success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePositionStatus(uint256,uint8)", positionId, 1
            )
        );
        require(success, "Status update failed");

        // Issue payout order
        if (payout > 0) {
            PayoutUpdate[] memory updates = new PayoutUpdate[](1);
            updates[0] = PayoutUpdate({
                recipient: makerAddress,
                required: payout,
                payoutType: 1
            });
            ISSListing(listingAddress).ssUpdate(listingAddress, updates);
        }
    }

    // Cancel position
    function cancelPosition(
        uint256 positionId,
        address listingAddress,
        address makerAddress,
        uint256 taxedMargin,
        uint256 excessMargin,
        uint8 positionType,
        address driver
    ) external {
        // Refund margin
        address token = positionType == 0 ? ISSListing(listingAddress).tokenA() : ISSListing(listingAddress).tokenB();
        if (token == address(0)) {
            payable(makerAddress).transfer(taxedMargin + excessMargin);
        } else {
            IERC20(token).safeTransfer(makerAddress, taxedMargin + excessMargin);
        }

        // Update status
        (bool success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePositionStatus(uint256,uint8)", positionId, 2
            )
        );
        require(success, "Status update failed");
    }

    // Force execution
    function forceExecution(
        address listingAddress,
        address driver
    ) external returns (uint256 resultCount) {
        resultCount = 0;
        uint256 maxActions = 50;
        uint256 currentPrice = ISSListing(listingAddress).prices(listingAddress);

        // Process pending positions
        for (uint8 positionType = 0; positionType <= 1 && resultCount < maxActions; positionType++) {
            (bool success, bytes memory data) = driver.call(
                abi.encodeWithSignature(
                    "pendingPositions(address,uint8)",
                    listingAddress,
                    positionType
                )
            );
            require(success, "Pending query failed");
            uint256[] memory pending = abi.decode(data, (uint256[]));
            for (uint256 i = 0; i < pending.length && resultCount < maxActions; i++) {
                uint256 positionId = pending[i];
                PositionDetails memory pos = ISSCrossDriver(driver).positionDetails(positionId);
                if (pos.status1 == false && pos.status2 == 0) {
                    if (currentPrice >= pos.minPrice && currentPrice <= pos.maxPrice) {
                        (success, ) = driver.call(
                            abi.encodeWithSignature(
                                "updatePositionStatus(uint256,uint8)", positionId, 0
                            )
                        );
                        if (success) {
                            pos.status1 = true;
                            (success, ) = driver.call(
                                abi.encodeWithSignature(
                                    "setPositionDetails(uint256,(address,uint256,uint256,uint256,uint256,uint256,uint8,uint256,uint256,uint256,uint256,uint256,uint8,bool,uint8,uint256,uint256,uint256,address))",
                                    positionId,
                                    pos
                                )
                            );
                            if (success) resultCount++;
                        }
                    }
                }
            }
        }

        // Process active positions
        for (uint8 positionType = 0; positionType <= 1 && resultCount < maxActions; positionType++) {
            (bool success, bytes memory data) = driver.call(
                abi.encodeWithSignature(
                    "positionsByType(uint8)",
                    positionType
                )
            );
            require(success, "Positions query failed");
            uint256[] memory active = abi.decode(data, (uint256[]));
            for (uint256 i = 0; i < active.length && resultCount < maxActions; i++) {
                uint256 positionId = active[i];
                PositionDetails memory pos = ISSCrossDriver(driver).positionDetails(positionId);
                if (pos.status1 == true && pos.status2 == 0 && pos.listingAddress == listingAddress) {
                    bool shouldClose = false;
                    if (pos.positionType == 0) {
                        if (pos.stopLossPrice > 0 && currentPrice <= pos.stopLossPrice) shouldClose = true;
                        else if (pos.takeProfitPrice > 0 && currentPrice >= pos.takeProfitPrice) shouldClose = true;
                        else if (currentPrice <= pos.liquidationPrice) shouldClose = true;
                    } else {
                        if (pos.stopLossPrice > 0 && currentPrice >= pos.stopLossPrice) shouldClose = true;
                        else if (pos.takeProfitPrice > 0 && currentPrice <= pos.takeProfitPrice) shouldClose = true;
                        else if (currentPrice >= pos.liquidationPrice) shouldClose = true;
                    }

                    if (shouldClose) {
                        (success, bytes memory marginData) = driver.call(
                            abi.encodeWithSignature(
                                "makerTokenMargin(address,address)",
                                pos.makerAddress,
                                pos.positionType == 0 ? ISSListing(pos.listingAddress).tokenA() : ISSListing(pos.listingAddress).tokenB()
                            )
                        );
                        require(success, "Margin query failed");
                        uint256 totalMargin = abi.decode(marginData, (uint256));

                        if (pos.positionType == 0) {
                            closeLongPosition(
                                positionId,
                                pos.listingAddress,
                                pos.makerAddress,
                                pos.taxedMargin,
                                pos.excessMargin,
                                pos.leverageAmount,
                                pos.initialLoan,
                                totalMargin,
                                driver
                            );
                        } else {
                            closeShortPosition(
                                positionId,
                                pos.listingAddress,
                                pos.makerAddress,
                                pos.minPrice,
                                pos.initialMargin,
                                pos.leverage,
                                pos.taxedMargin,
                                pos.excessMargin,
                                totalMargin,
                                driver
                            );
                        }
                        resultCount++;
                    }
                }
            }
        }
    }

    // Add excess margin
    function addExcessMargin(
        address maker,
        uint256 amount,
        address token,
        uint256 normalizedAmount,
        address driver
    ) external {
        require(amount > 0, "Invalid amount");
        if (token == address(0)) {
            payable(driver).transfer(amount);
        } else {
            IERC20(token).safeTransfer(driver, amount);
        }
    }

    // Update stop loss
    function updateSL(
        uint256 positionId,
        uint256 newStopLossPrice,
        address listingAddress,
        uint8 positionType,
        address makerAddress,
        uint256 minPrice,
        uint256 maxPrice,
        address driver
    ) external {
        (bool success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePositionSL(uint256,uint256)", positionId, newStopLossPrice
            )
        );
        require(success, "SL update failed");
    }

    // Update take profit
    function updateTP(
        uint256 positionId,
        uint256 newTakeProfitPrice,
        uint8 positionType,
        address makerAddress,
        uint256 minPrice,
        uint256 maxPrice,
        address driver
    ) external {
        (bool success, ) = driver.call(
            abi.encodeWithSignature(
                "updatePositionTP(uint256,uint256)", positionId, newTakeProfitPrice
            )
        );
        require(success, "TP update failed");
    }

    // Batch operations
    function closeAllShort(address user, address driver) external returns (uint256 count) {
        count = 0;
        (bool success, bytes memory data) = driver.call(
            abi.encodeWithSignature(
                "positionsByType(uint8)",
                1
            )
        );
        require(success, "Positions query failed");
        uint256[] memory positions = abi.decode(data, (uint256[]));
        for (uint256 i = 0; i < positions.length; i++) {
            PositionDetails memory pos = ISSCrossDriver(driver).positionDetails(positions[i]);
            if (pos.makerAddress == user && pos.status2 == 0 && pos.positionType == 1) {
                (success, bytes memory marginData) = driver.call(
                    abi.encodeWithSignature(
                        "makerTokenMargin(address,address)",
                        pos.makerAddress,
                        ISSListing(pos.listingAddress).tokenB()
                    )
                );
                require(success, "Margin query failed");
                uint256 totalMargin = abi.decode(marginData, (uint256));

                closeShortPosition(
                    positions[i],
                    pos.listingAddress,
                    pos.makerAddress,
                    pos.minPrice,
                    pos.initialMargin,
                    pos.leverage,
                    pos.taxedMargin,
                    pos.excessMargin,
                    totalMargin,
                    driver
                );
                count++;
            }
        }
    }

    function cancelAllShort(address user, address driver) external returns (uint256 count) {
        count = 0;
        (bool success, bytes memory data) = driver.call(
            abi.encodeWithSignature(
                "pendingPositions(address,uint8)",
                address(0),
                1
            )
        );
        require(success, "Pending query failed");
        uint256[] memory positions = abi.decode(data, (uint256[]));
        for (uint256 i = 0; i < positions.length; i++) {
            PositionDetails memory pos = ISSCrossDriver(driver).positionDetails(positions[i]);
            if (pos.makerAddress == user && pos.status1 == false && pos.status2 == 0 && pos.positionType == 1) {
                cancelPosition(
                    positions[i],
                    pos.listingAddress,
                    pos.makerAddress,
                    pos.taxedMargin,
                    pos.excessMargin,
                    pos.positionType,
                    driver
                );
                count++;
            }
        }
    }

    function closeAllLongs(address user, address driver) external returns (uint256 count) {
        count = 0;
        (bool success, bytes memory data) = driver.call(
            abi.encodeWithSignature(
                "positionsByType(uint8)",
                0
            )
        );
        require(success, "Positions query failed");
        uint256[] memory positions = abi.decode(data, (uint256[]));
        for (uint256 i = 0; i < positions.length; i++) {
            PositionDetails memory pos = ISSCrossDriver(driver).positionDetails(positions[i]);
            if (pos.makerAddress == user && pos.status2 == 0 && pos.positionType == 0) {
                (success, bytes memory marginData) = driver.call(
                    abi.encodeWithSignature(
                        "makerTokenMargin(address,address)",
                        pos.makerAddress,
                        ISSListing(pos.listingAddress).tokenA()
                    )
                );
                require(success, "Margin query failed");
                uint256 totalMargin = abi.decode(marginData, (uint256));

                closeLongPosition(
                    positions[i],
                    pos.listingAddress,
                    pos.makerAddress,
                    pos.taxedMargin,
                    pos.excessMargin,
                    pos.leverageAmount,
                    pos.initialLoan,
                    totalMargin,
                    driver
                );
                count++;
            }
        }
    }

    function cancelAllLong(address user, address driver) external returns (uint256 count) {
        count = 0;
        (bool success, bytes memory data) = driver.call(
            abi.encodeWithSignature(
                "pendingPositions(address,uint8)",
                address(0),
                0
            )
        );
        require(success, "Pending query failed");
        uint256[] memory positions = abi.decode(data, (uint256[]));
        for (uint256 i = 0; i < positions.length; i++) {
            PositionDetails memory pos = ISSCrossDriver(driver).positionDetails(positions[i]);
            if (pos.makerAddress == user && pos.status1 == false && pos.status2 == 0 && pos.positionType == 0) {
                cancelPosition(
                    positions[i],
                    pos.listingAddress,
                    pos.makerAddress,
                    pos.taxedMargin,
                    pos.excessMargin,
                    pos.positionType,
                    driver
                );
                count++;
            }
        }
    }
}